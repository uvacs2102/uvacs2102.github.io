<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cs2102: Discrete Math</title>
    <link>https://uvacs2102.github.io/index.xml</link>
    <description>Recent content on cs2102: Discrete Math</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Nov 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://uvacs2102.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Schedule Updates</title>
      <link>https://uvacs2102.github.io/scheduleupdates/</link>
      <pubDate>Sun, 12 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/scheduleupdates/</guid>
      <description>&lt;p&gt;We are adjusting the schedule for Problem Set 9 and Problem Set
&amp;Omega; from the original schedule. Instead of being due on Wednesday,
November 22 as previously scheduled, Problem Set 9 will now be due on
Friday, 1 December (6:29pm). Its scope will be expanded to include
Classes 20-24, and we expect to posted it on November 19.&lt;/p&gt;

&lt;p&gt;Problem Set &amp;Omega; (which is optional and different, and will be
discussed in class this week) will now be due on Monday, 4 December
(11:59pm).&lt;/p&gt;

&lt;p&gt;If the schedule change causes any hardship for you, and you would
prefer to have a PS9 due on Nov 22, let one of the professors know and
we can arrange something different.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Class 21: Review</title>
      <link>https://uvacs2102.github.io/class21/</link>
      <pubDate>Tue, 07 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/class21/</guid>
      <description>

&lt;h3 id=&#34;exam-2&#34;&gt;Exam 2&lt;/h3&gt;

&lt;p&gt;Exam 2 will be in class on Thursday, 9 Nov. See &lt;a href=&#34;https://uvacs2102.github.io/docs/class20.pdf&#34;&gt;Class 20&lt;/a&gt; notes for details on the exam.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;
   &lt;center&gt;
&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;13a56eac91bd4098840e980ed10fc01f&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
   &lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightm&#34;&gt;
   &lt;a href=&#34;https://uvacs2102.github.io/docs/class21.pdf&#34;&gt;See PDF Version for &lt;b&gt;Notes and Questions&lt;/b&gt;&lt;/a&gt;.
   &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;latex&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;main-topics-for-review&#34;&gt;Main Topics for Review&lt;/h2&gt;

&lt;p&gt;Today we review the topics that we learned after Exam 1 with the
exception of number theory (which will not be included in Exam
2).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;State Machines and how to argue about correctness of programs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Recursive Definitions and how to prove statements about them using structural induction.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Infinite Sets and Cardinalities, and how to show sets are finite, infinite, countable, or uncountable.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;state-machines&#34;&gt;State Machines&lt;/h2&gt;

&lt;p&gt;$M = (S, G \subset S \times S, q_0 \in S)$ defines a state machine.&lt;/p&gt;

&lt;p&gt;$P$ is a &lt;em&gt;preserved invariant&lt;/em&gt; if:
$$ \forall q \in S. (P(q) \wedge (q \rightarrow r) \in G) \implies P&amp;reg;$$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Invariant Principle:&lt;/strong&gt; If $P$ is a &lt;em&gt;preserved invariant&lt;/em&gt; and
  $P(q_0)$ is true, then property $P$ is true for all &lt;strong&gt;reachable
  states&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;proving-program-correctness&#34;&gt;Proving Program Correctness&lt;/h2&gt;

&lt;p&gt;To prove a program $R$ produces the correct output:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Model it as a state machine, $M$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Show that $M$ eventually terminates.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Show partial correctness:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Find a suitable preserved invariant $P$ for $M$.&lt;/li&gt;
&lt;li&gt;Show that $P(q)$ for all final states implies the output correctness property. (Final states are states where the execution terminates.)&lt;/li&gt;
&lt;li&gt;Show $P(q_0)$ &amp;mdash; the perserved invariant holds for the start state.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--page--&gt;

&lt;h2 id=&#34;recursive-data-types&#34;&gt;Recursive Data Types&lt;/h2&gt;

&lt;p&gt;To define a recursive data type $D$:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Define one or more &lt;strong&gt;base&lt;/strong&gt; objects, $d \in D$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Define one or more &lt;strong&gt;constructor&lt;/strong&gt; cases that specify how to construct a new object $d \in D$ from one or more previoulsy-constructed objects, $d_1, d_2, \ldots \in D$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Problem Set 8 Comments</title>
      <link>https://uvacs2102.github.io/ps8comments/</link>
      <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/ps8comments/</guid>
      <description>&lt;p&gt;The Problem Set 8 solutions and comments are now posted in collab: &lt;a href=&#34;https://collab.its.virginia.edu/access/content/group/9bd99d1c-6f18-4542-a7d1-8ffc4fccbd3d/ps8solutions.pdf&#34;&gt;PDF&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Class 20: Number Theory</title>
      <link>https://uvacs2102.github.io/class20/</link>
      <pubDate>Thu, 02 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/class20/</guid>
      <description>

&lt;h3 id=&#34;schedule&#34;&gt;Schedule&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://uvacs2102.github.io/ps/ps8&#34;&gt;&lt;strong&gt;Problem Set 8&lt;/strong&gt;&lt;/a&gt; is due &lt;strong&gt;Friday at 6:29pm&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tuesday&amp;rsquo;s class&lt;/strong&gt; will include a review for Exam 2.  Before 6:59pm
  Monday, send to &lt;a href=&#34;mailto:uvacs2102staff@gmail.com&#34;&gt;&lt;em&gt;uvacs2102staff@gmail.com&lt;/em&gt;&lt;/a&gt; topics you would like to review. We will have a similar rule to Exam 1:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fewer than 10 total requests: it means, class is not being sufficiently challenged and we should be doing more difficult material (except for the 10 requestors who get exam exemptions).&lt;/li&gt;
&lt;li&gt;Exactly 10 total requests: all requestors get automatic exam exemptions, review requested topics.&lt;/li&gt;
&lt;li&gt;More than 10 requests implies we should spend Thursdayâ€™s class on reviewing requested topics, no exam exemptions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;exam-2&#34;&gt;Exam 2&lt;/h3&gt;

&lt;p&gt;Exam 2 will be in class on Thursday, 9 Nov.  You can get a good
idea for what to expect on Exam 2 based on Exam 1, and also by looking at the &lt;a href=&#34;https://uvacs2102.github.io/docs/practiceexam2.pdf&#34;&gt;Practice Exam
2&lt;/a&gt; (from last year&amp;rsquo;s class). We strongly
encourage you to try to problems on your own, before looking at the
&lt;a href=&#34;https://uvacs2102.github.io/docs/practiceexam2-solutions.pdf&#34;&gt;posted solutions&lt;/a&gt;. The main difference is that this year, we did not cover the topic of &amp;ldquo;stable marriage&amp;rdquo;, but the our exam 2 will also cover the topic of infinities (i.e. infinite sets, countable and uncountable sets, etc.) as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resources.&lt;/strong&gt; Similarly to Exam 1, you will be permitted to use a &lt;em&gt;single paper page&lt;/em&gt; of
notes that you prepare and bring to the exam.  It is fine to
collaborate with others to prepare your notes.  The page should be no
larger than a US Letter size page ($8.5 \times 11$ inches), and you
may write (or print) on both sides of the page.  You may not use any
special devices (e.g., magnifying glasses) to read your page. No other
resources, other than your own brain, body, and writing instrument,
are permitted during the exam.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Content.&lt;/strong&gt; The problems on the exam will cover material from Classes
  1&amp;ndash;19, Problem Sets 1&amp;ndash;8 (including the provided solutions), and the relevant material from MCS
  Chapters 1&amp;ndash;8. However, only one problem will be about the material covered by Exam 1, and the rest will be on the material we covered since Exam 1 (namely, classes 13-19, problem sets 6&amp;ndash;8, and chapters 6,7,8).  Everything on the exam will be something you have seen
  in at least two of these (Classes, Problem Sets, and MCS Book), and
  most of the exam will be things you have seen in all three.  If you
  understand the problems on the problem sets and questions on the class
  notes well enough to be able to answer similar questions, you should
  do well on the exam.&lt;/p&gt;

&lt;p&gt;Simiarly to Exam 1, for most students, we believe the best way to prepare for the exam
will be to (1) go over the problem sets and their solutions, and make
sure you understand well any of the problems you did not get before;
(2) go through the provided practice exam and try to solve all the
problems on your own before reading the solutions; (3) go through the
questions in the class notes and convince yourself you can answer them
well; (4) re-read chapters of the book, solving the associated
practice problems, especially for any sections on topics where you had
difficulty on the problem sets.  If you do #1 and #2 and understand
well the problems on the practice exam, you should be confident you&amp;rsquo;ll
do well on the exam; if you struggled on the problem sets, you would
benefit from doing #3 and #4 as well.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;
   &lt;center&gt;
&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;e587be0cca304366bf9242a5a79d42de&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
   &lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightm&#34;&gt;
   &lt;a href=&#34;https://uvacs2102.github.io/docs/class20.pdf&#34;&gt;See PDF Version for &lt;b&gt;Notes and Questions&lt;/b&gt;&lt;/a&gt;.
   &lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Goldbach%27s_conjecture&#34;&gt;Goldbach&amp;rsquo;s conjecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.britannica.com/topic/twin-prime-conjecture&#34;&gt;Twin Prime&amp;rsquo;s conjecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem&#34;&gt;Fermat&amp;rsquo;s last theorem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;latex&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;divisibility&#34;&gt;Divisibility&lt;/h2&gt;

&lt;p&gt;Number theory is a study of integers $\mathbb{Z}={0,-1,1,-2,2,\dots}$. Adding, multiplying, and negating, are 3 operators on integers that we can define in a straight-forward way. Dividing is more tricky. For that, we first define the notation $a \mid b$ to denote the simpler situation where $b = k \cdot a$ for some $k \in \mathbb{Z}$. In this case, we say that $a$ is a &lt;em&gt;divisor&lt;/em&gt; of $b$ and that $b$ is a &lt;em&gt;multiple&lt;/em&gt; of $a$.&lt;/p&gt;

&lt;p&gt;Show that if we assume $a \mid b$ and $a \mid c$ (for any integers $a,b,c$), then for all integers $x,y$ it will hold that $a \mid xa + yb$.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;When   $b$ is \emph{not} a multiple of $a$, we can still have some form of division, stated in the following theorem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem [Division Theorem]&lt;/strong&gt; For all integers $n,d$, there are integers $q$ (called the quotiont) and $r$ (called the remainder, denoted by $rem(m,d)$) such that
$$n = q \cdot d + r \text{&lt;del&gt;and&lt;/del&gt;}  0\leq r &amp;lt; |d|.$$
Note that the remainder, as defined here, is always non-negative. For example when dividing $-3$ by $5$ we get $q=-1$ and $r=2$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt; A &lt;em&gt;prime&lt;/em&gt; $p$, is an integer $p&amp;gt;1$ such that  $1$ and $p$ are the only positive divisors of $p$. Other $n&amp;gt;1$ numbers (that are not prime) are called composite.&lt;/p&gt;

&lt;p&gt;The following well-known  theorem can be proved by strong induction on $n$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem [Fundamental theorem of arithmetic]&lt;/strong&gt;. Any $n&amp;gt;1$ has a unique represention in the following form:
$$ n = p_1^{a_1} \dots p_k^{a_k}$$
where $p&lt;em&gt;i &amp;lt; p&lt;/em&gt;{i+1}$ and $p_i$ is prime for all $i$.&lt;/p&gt;

&lt;p&gt;Hint for proof: Use strong induction on $n$, and try to show that any two different representations for $n$ will have the same `smallest&amp;rsquo; prime $p_1$ and the same power $a_1$ for $p_1$.&lt;/p&gt;

&lt;h2 id=&#34;easy-to-state-but-hard-to-solve-problems&#34;&gt;Easy-to-state, but hard-to-solve problems&lt;/h2&gt;

&lt;p&gt;In number theory, we can easily state problems that are super hard to solve. These are some examples.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Goldbach&amp;rsquo;s conjecture:&lt;/strong&gt; Any even integer $n&amp;gt;2$ can be written as $n=p+q$ where $p,q$ are both primes. The conjecture is still open, though we know that it is correct for all $n \leq 10^{18}$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Twin prime&amp;rsquo;s conjecture:&lt;/strong&gt; There infinite prime numbers $p$ where $p+2$ is also prime. Note that we cannot `check the conjecture up to $n$&amp;rsquo; anymore! And it is still open&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fermat&amp;rsquo;s last theorem:&lt;/strong&gt; For any integer $n&amp;gt;2$ there are no integers $a,b,c$ where $a^n + b^n = c^n$. Note that for $n=2$ there are integer solutions like $3^2 + 4^2 = 5^2$. Fermat claimed to have a proof, but nobody knows if he really did or not. Andrew Wiles eventually proved this in 1994, hence we call it a &lt;em&gt;theorem&lt;/em&gt; and not a conjecture anymore.&lt;/p&gt;

&lt;h2 id=&#34;greatest-common-divisor&#34;&gt;Greatest Common Divisor&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt; For natural numbers $m,n&amp;gt;0$ we call $d&amp;gt;0$ their \emph{greatest common divisor}, denoted by $d=gcd(m,n)$ if $d$ is the largest number such that $d \mid m$ and $d \mid n$. (Make sure to verify why we can always say that such $d$ exists.)&lt;/p&gt;

&lt;p&gt;We can use the fundamental theorem of arithmetic, to &lt;em&gt;compute&lt;/em&gt; the gcd of any given pairs of integers. But how efficient is it? The problem is that factoring numbers $m,n$ into their prime factors is not something we know how to do efficiently. In particular, no known algorithm is guaranteed to factor all numbers with $1000,000$ digits in less than an (estimated) thousand years! The conjecture is that no such `efficient&amp;rsquo; algorithm exists, and many cryptographic algorithms &lt;em&gt;assume&lt;/em&gt; this is the case!&lt;/p&gt;

&lt;h2 id=&#34;euclid-s-algorithm&#34;&gt;Euclid&amp;rsquo;s Algorithm&lt;/h2&gt;

&lt;p&gt;Despite not knowing how to factor integers efficiently, Euclid showed how to find gcd quite efficiently. This shows, even if the most ``natural&amp;rdquo; algorithm fails for doing something efficiently, we should always consider the possibility that an alternative way could still exist.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def Euclid_gcd(m, n):
   while n &amp;gt; 0:
      r = rem(m,n)
      m = n
      n = r
   return m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is a good state machine modeling the behavior of Euclid&amp;rsquo;s algorithm?&lt;/p&gt;

&lt;p&gt;Suppose $d$ is any integer (in particular, it could be the gcd of the original state $(m,n)$ of the state machine for Eclid&amp;rsquo;s algorithm). Show that $gcd(a,b)=d$ is a preserved invariant for the transition graph of this state machine. Namely, if we go from one state to another state, the gcd does not change.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;If the Euclid&amp;rsquo;s algorithm ends, at the very last step we will have $n=0$ which means $m$ is indeed the right gcd for that particular (final) state. Together with the preserved invariant (that you proved above), argue that the program has \emph{partial correctness}. Namely: if it ends, it outputs correctly.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;Now prove the termination. Namely, show that the Euclid&amp;rsquo;s gcd algorithm will always end. Hint, look at $a+b$ for any state $(a,b)$ that we are in, and show that it always
decreases.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;Amazing thing about Euclid&amp;rsquo;s algorithm is that it is indeed quite efficient. A better analysis shows that it will always terminate in $\log (m+n)$ steps. (Hint: show that after two steps, $m$ will be at most &lt;em&gt;half&lt;/em&gt; of what it was before..)
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Problem Set 7 Comments</title>
      <link>https://uvacs2102.github.io/ps7comments/</link>
      <pubDate>Wed, 01 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/ps7comments/</guid>
      <description>&lt;p&gt;The Problem Set 7 solutions and comments are now posted in collab: &lt;a href=&#34;https://collab.its.virginia.edu/access/content/group/9bd99d1c-6f18-4542-a7d1-8ffc4fccbd3d/ps7solutions.pdf&#34;&gt;PDF&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Class 19: Reviewing Infinities</title>
      <link>https://uvacs2102.github.io/class19/</link>
      <pubDate>Tue, 31 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/class19/</guid>
      <description>

&lt;h3 id=&#34;schedule&#34;&gt;Schedule&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Set 8&lt;/strong&gt; is now due on &lt;strong&gt;Friday, Nov 3&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;
   &lt;center&gt;
&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;5db039183a334bca9708c9f6c0d3b9dc&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
   &lt;/center&gt;
   &lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightm&#34;&gt;
   &lt;a href=&#34;https://uvacs2102.github.io/docs/class19.pdf&#34;&gt;See PDF Version for &lt;b&gt;Notes&lt;/b&gt;&lt;/a&gt;.
   &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;latex&#34;&gt;&lt;/p&gt;

&lt;h1 id=&#34;comparing-sets-recap&#34;&gt;Comparing sets Recap:&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; Sets $A$ and $B$ have the same cardinality, denoted by $|A|=|B|$ if there is a bijection between $A$ and $B$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; Cardinality of $A$ is at least as big as cardinality of $B$, denoted by $|A|\geq |B|$ if and only if &lt;em&gt;either&lt;/em&gt; of the following is true (they are equivalent).
\begin{enumerate}
\item There is a surjective function from $A$ to $B$.
\item There is a total injective function from $B$ to $A$.
\end{enumerate}&lt;/p&gt;

&lt;h1 id=&#34;infinite-sets-recap&#34;&gt;Infinite Sets Recap&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A set $C$ is &lt;em&gt;infinite&lt;/em&gt; if and only if &lt;em&gt;either&lt;/em&gt; of the following happens (they are all equivalnet).
\begin{enumerate}&lt;/p&gt;

&lt;p&gt;\item Dedekind-infinite: There is a bijection between $C$ and a strict subset $B$ of $C$.&lt;/p&gt;

&lt;p&gt;\item There is \emph{no} bijection between $C$ and any $\mathbb{N}_k$ for any natural number $ k \in \mathbb{N}$.&lt;/p&gt;

&lt;p&gt;\item There exists a
  surjective function from $C$ to $\mathbb{N}$.&lt;/p&gt;

&lt;p&gt;\item There exists a total injective function from $\mathbb{N}$  to $C$.
\end{enumerate}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A set $C$ is &lt;em&gt;countable&lt;/em&gt; if and only if there exists a
  surjective function from $\mathbb{N}$ to $C$.  (That is, $\le 1$ arrow
  out from $\mathbb{N}$, $\ge 1$ arrow in to $C$.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A set $C$ is &lt;em&gt;countably infinite&lt;/em&gt; if and only if there
  exists a bijection between $C$ and $\mathbb{N}$.&lt;/p&gt;

&lt;h1 id=&#34;cantor-s-theorem&#34;&gt;Cantor&amp;rsquo;s Theorem&lt;/h1&gt;

&lt;p&gt;For &lt;strong&gt;all&lt;/strong&gt; sets, $S$, $| pow(S) | &amp;gt; | S |$.&lt;/p&gt;

&lt;p&gt;What does this mean for $| \mathbb{N} |$?&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;Show there is a bijection between $[0, 1]$ and $pow(\mathbb{N})$.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;What is the cardinality of all the real numbers? Show a bijection between $[0, 1]$ and all real numbers. Hint, first show a bijection between $(0, 1)$ and real numbers, and then a bijection between $[0, 1]$ and $(0, 1)$.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Problem Set 8</title>
      <link>https://uvacs2102.github.io/ps8posted/</link>
      <pubDate>Sat, 28 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/ps8posted/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://uvacs2102.github.io/ps/ps8&#34;&gt;&lt;strong&gt;Problem Set 8&lt;/strong&gt;&lt;/a&gt; [&lt;a href=&#34;https://uvacs2102.github.io/docs/ps8.pdf&#34;&gt;PDF&lt;/a&gt;] is now posted and
is due &lt;strong&gt;Friday, 3 Nov at 6:29:00pm&lt;/strong&gt;. Please read the
collaboration policy carefully.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Problem Set 8</title>
      <link>https://uvacs2102.github.io/ps/ps8/</link>
      <pubDate>Fri, 27 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/ps/ps8/</guid>
      <description>

&lt;div class=&#34;latex&#34;&gt;
   \dbox{{\bf Deliverable:} Submit your responses as a
single, readable PDF file on the collab site before {\bf 6:29pm} on {\bf
   Friday, 3 November}.}
   &lt;/div&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;
   &lt;div class=&#34;highlightr&#34;&gt;
   &lt;strong&gt;Deliverable:&lt;/strong&gt; Submit your responses as a
single, readable PDF file on the collab site before &lt;strong&gt;6:29pm&lt;/strong&gt; on
   &lt;strong&gt;Friday, 3 November&lt;/strong&gt;.
   &lt;/div&gt;
   &lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;h3 id=&#34;collaboration-policy-collaboration-policy-identical-to-ps5&#34;&gt;Collaboration Policy - Collaboration Policy (identical to PS5)&lt;/h3&gt;

&lt;p&gt;For this assignment, you may work in groups of one to three students
to write-up a solution together.  If you work with teammates, exactly
one of you should submit one assignment that represents your
collective best work with all of your names and UVA ids clearly marked
on it on it.  &lt;em&gt;Everyone on a team should understand everything you
turn in for the assignment well enough to be able to produce it
completely on your own.&lt;/em&gt; All teammates must review the submissions
before it is submitted to make sure you understand everything on it
and that your name and UVA id are clearly marked on it.&lt;/p&gt;

&lt;h2 id=&#34;preparation&#34;&gt;Preparation&lt;/h2&gt;

&lt;p&gt;This problem set focuses on infinite sets &amp;mdash; Chapter 8 of the MCS book,
and &lt;a href=&#34;https://uvacs2102.github.io/class17&#34;&gt;Class 17&lt;/a&gt;, &lt;a href=&#34;https://uvacs2102.github.io/class18&#34;&gt;Class 18&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightm&#34;&gt;
    &lt;a href=&#34;https://uvacs2102.github.io/docs/ps8.pdf&#34;&gt;Download PDF for Problems&lt;/a&gt;.
   &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightr&#34;&gt;
Your response should be submitted as a single PDF file using collab.  Please read and follow the &lt;a href=&#34;https://uvacs2102.github.io/pdfs/&#34;&gt;Generating PDFs&lt;/a&gt; advice on the course site.
   &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;latex&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;directions&#34;&gt;Directions&lt;/h2&gt;

&lt;p&gt;Solve all 8 problems.  Your answers should be clear, consise, and convincing.&lt;/p&gt;

&lt;h3 id=&#34;countable-sets&#34;&gt;Countable Sets&lt;/h3&gt;

&lt;p&gt;For each set defined below, prove that the set described is &lt;em&gt;countable&lt;/em&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$\text{\em Evens} = { 2n \, | \, n \in \mathbb{N} }$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\mathbb{N} \cup { \pi, \tau }$ (where $\pi$ is the ratio of a circle&amp;rsquo;s circumference to its diameter and $\tau$ is the ratio of a circle&amp;rsquo;s circumference to its radius)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The set $X$ of all finite state machines, $M = (S, G, q_0)$ where $S = \mathbb{N}_k$
for &lt;em&gt;some&lt;/em&gt; natural number $k&amp;gt;0$, and $G \subseteq S \times S$ and $q_0 \in S$ are
otherwise unrestricted. (Note that here we are &lt;em&gt;not&lt;/em&gt; working with a fixed $k$, and for example machines with  $S = \mathbb{N}_2$ and machines with $S = \mathbb{N}_9$ are both counted in the set $X$).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;possibly-countable-sets&#34;&gt;Possibly Countable Sets&lt;/h3&gt;

&lt;p&gt;For each set defined below, determine if the set is &lt;em&gt;countable&lt;/em&gt; or
&lt;em&gt;uncountable&lt;/em&gt; and support your answer with a convincing proof.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The set of all &lt;em&gt;stree&lt;/em&gt; objects, defined by:
\begin{itemize}
\item Base object: $\text{\bf null}$ is an {\em stree}.
\item Constructor: for any {\em stree} objects $q_1, q_2$, $\text{combine}(q_1, q_2)$ is an {\em stree}.
\end{itemize}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\mathbb{R} - \mathbb{Q}$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The set of all &lt;em&gt;infinite&lt;/em&gt; state machines, $M = (S, G, q_0)$ where $S = \mathbb{N}$, and $G \subseteq S \times S$ and $q_0 \in S$ are
otherwise unrestricted.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;properties-of-infinite-sets&#34;&gt;Properties of Infinite Sets&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In class 17 we defined a set $C$ to be countable, if there is a surjective function $f: \mathbb{N} \rightarrow C$. Prove that we get an equivalent definition if we call $C$ countable whenever then there is a &lt;em&gt;total&lt;/em&gt; surjective function, $$f: \mathbb{N} \rightarrow C.$$
Note that you  need to prove &lt;em&gt;two&lt;/em&gt; directions, that whenever $C$ satisfies in the first definition of countable, it does satisfy in the second definition of countable, and vice versa.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MCS Problem 8.23.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Class 18: Spooky Infinities</title>
      <link>https://uvacs2102.github.io/class18/</link>
      <pubDate>Thu, 26 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/class18/</guid>
      <description>

&lt;h3 id=&#34;schedule&#34;&gt;Schedule&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://uvacs2102.github.io/ps/ps7&#34;&gt;&lt;strong&gt;Problem Set 7&lt;/strong&gt;&lt;/a&gt; is due &lt;strong&gt;Friday (27 Oct) at 6:29pm&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exam 2&lt;/strong&gt; is two weeks from today (November 9, in class).  We will
  post more information about Exam 2 soon.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;
   &lt;center&gt;
&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;74956d35d8ae473d9e7c99973d8d9718&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
   &lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightm&#34;&gt;
   &lt;a href=&#34;https://uvacs2102.github.io/docs/class18.pdf&#34;&gt;See PDF Version for &lt;b&gt;Notes&lt;/b&gt;&lt;/a&gt;.
   &lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Logicomix-search-truth-Apostolos-Doxiadis/dp/1596914521/&#34;&gt;&lt;em&gt;Logicomix: An epic search for truth&lt;/em&gt;&lt;/a&gt;, comic book by Apostolos Doxiadis and &lt;a href=&#34;https://people.eecs.berkeley.edu/~christos/&#34;&gt;Christos H. Papadimitrou&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Last year, there was a &lt;a href=&#34;https://uvacs2102.github.io/f16/ps/psz/&#34;&gt;Problem Set &amp;omega;&lt;/a&gt; - you can see some examples of &lt;a href=&#34;https://uvacs2102.github.io/f16/pszhighlights/&#34;&gt;student&amp;rsquo;s work&lt;/a&gt;. (Note that having a PS &amp;omega; does not imply any limit on the number of regular problem sets, since there are infinitely many natural numbers before &amp;omega;!)&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;latex&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;countable-and-uncountable-sets&#34;&gt;Countable and Uncountable Sets&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A set $S$ is &lt;em&gt;countably infinite&lt;/em&gt; if and only if there
  exists a bijection between $S$ and $\mathbb{N}$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A set $S$ is &lt;em&gt;uncountable&lt;/em&gt;, if there exists no bijection
  between $S$ and $\mathbb{N}$.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;power set&lt;/strong&gt; of $A$ ($\textrm{pow}(A)$)is the set of all subsets of $A$:
$$
B \in \textrm{pow}(A) \iff B \subseteq A.
$$&lt;/p&gt;

&lt;p&gt;For all &lt;strong&gt;finite&lt;/strong&gt; sets $S$, $|pow(S)| = 2^{|S|}$.&lt;/p&gt;

&lt;p&gt;#
#&lt;/p&gt;

&lt;p&gt;For &lt;strong&gt;all&lt;/strong&gt; sets $S$, $|pow(S)| &amp;gt; |S|$.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;Prove $pow(\mathbb{N})$ is uncountable.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;$\text{bitstrings} = \forall n \in \mathbb{N} . {0, 1}^n$.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;!--page--&gt;

&lt;h2 id=&#34;ordinal-and-cardinal-numbers&#34;&gt;Ordinal and Cardinal Numbers&lt;/h2&gt;

&lt;p&gt;$\omega$ is the &lt;em&gt;smallest infinite ordinal&lt;/em&gt;.  The first ordinal after
$0, 1, 2, \cdots$.&lt;/p&gt;

&lt;p&gt;What is the difference between an &lt;em&gt;ordinal&lt;/em&gt; and &lt;em&gt;cardinal&lt;/em&gt; number?&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;p&gt;What should $2\omega$ mean?&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;p&gt;Is $\text{InfiniteBitStrings} = {0, 1}^\omega$ countable?&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;Prove the number of real numbers in the interval $[0, 1]$ is uncountable.&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Problem Set 6 Comments</title>
      <link>https://uvacs2102.github.io/ps6comments/</link>
      <pubDate>Wed, 25 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/ps6comments/</guid>
      <description>&lt;p&gt;The Problem Set 6 solutions and comments are now posted in collab: &lt;a href=&#34;https://collab.its.virginia.edu/access/content/group/9bd99d1c-6f18-4542-a7d1-8ffc4fccbd3d/ps6solutions.pdf&#34;&gt;PDF&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Class 17: Infinite Sets</title>
      <link>https://uvacs2102.github.io/class17/</link>
      <pubDate>Tue, 24 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/class17/</guid>
      <description>

&lt;h3 id=&#34;schedule&#34;&gt;Schedule&lt;/h3&gt;

&lt;p&gt;Before Thursday, everyone should have finished reading MCS Chapter 8.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://uvacs2102.github.io/ps/ps7&#34;&gt;&lt;strong&gt;Problem Set 7&lt;/strong&gt;&lt;/a&gt; is due &lt;strong&gt;Friday (27 Oct) at 6:29pm&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;
   &lt;center&gt;
&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;57544e0622ea4b4cbe07b4e4385eca85&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
   &lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightm&#34;&gt;
   &lt;a href=&#34;https://uvacs2102.github.io/docs/class17.pdf&#34;&gt;See PDF Version for &lt;b&gt;Notes&lt;/b&gt;&lt;/a&gt;.
   &lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs2800/2017fa/lectures/lec14-cantor.html&#34;&gt;Proof of Schr&amp;ouml;der-Bernstein Theorem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;latex&#34;&gt;&lt;/p&gt;

&lt;h1 id=&#34;infinite-sets&#34;&gt;Infinite Sets&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Finite Cardinality.&lt;/strong&gt; The &lt;em&gt;cardinality&lt;/em&gt; of the set
$$
\mathbb{N}_k = { n | n \in \mathbb{N} \wedge n &amp;lt; k }
$$
is $k$.  If there is a &lt;em&gt;bijection&lt;/em&gt; between two sets, they have the same
cardinality.  (Class 9)&lt;/p&gt;

&lt;p&gt;Does this definition tell us the cardinality of $\mathbb{N}$?&lt;/p&gt;

&lt;p&gt;###&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A set $S$ is &lt;em&gt;infinite&lt;/em&gt; if there is no bijection between
  $S$ and any set $\mathbb{N}_k$ (as defined above).&lt;/p&gt;

&lt;p&gt;Show that $\mathbb{Z}$ is infinite.&lt;/p&gt;

&lt;h3 id=&#34;cardinality-of-infinite-sets&#34;&gt;Cardinality of Infinite Sets&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Equal Carinalities.&lt;/strong&gt; We say $|A|\; = |B|$  for arbitrary sets $A,B$ (and say that they have the same cardinality), if there is a bijection between $A$ and $B$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Comparing Cardinalities.&lt;/strong&gt; We say $|B|\; \leq |A|$  for arbitrary sets $A,B$ (and say that $B$&amp;rsquo;s cardinality is less than or equal to the cardinality of $A$), if there is a &lt;em&gt;surjective function&lt;/em&gt; from $A$ to $B$.&lt;/p&gt;

&lt;p&gt;Show that $|A|\; = |B|$ implies $|B|\; \leq |A|$ and $|A|\; \leq |B|$. Be careful as these sets might not be finite, in which case we cannot simply use natural numbers to denote their cardinalities.&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Schr\wrap{\&amp;ldquo;{o}}der-Bernstein Theorem:&lt;/strong&gt; If $|A|\; \leq |B|$ and $|B|\; \leq |A|$, then there is a bijection between $A$ and $B$, namely $|A|\; = |B|$. (Not proven in cs2102; this is somewhat tricky to prove! For a full proof, see &lt;a href=&#34;http://www.cs.cornell.edu/courses/cs2800/2017fa/lectures/lec14-cantor.html&#34;&gt;the linked lecture notes&lt;/a&gt;.)&lt;/p&gt;

&lt;h3 id=&#34;other-definitions-for-infinite-sets&#34;&gt;Other Definitions for Infinite Sets&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Dedekind-Infinite.&lt;/strong&gt; A set $A$ is &lt;em&gt;Dedekind-infinite&lt;/em&gt; if and only if there exists a &lt;em&gt;strict subset&lt;/em&gt; of $A$ with the same cardinality as $A$.  That is,
$$\exists B \subset A \ldotp \exists R \ldotp R\ \text{is a bijection between}\ A\ \text{and}\ B.$$&lt;/p&gt;

&lt;p&gt;Recall the definition of strict subset:
$$B \subset A \iff B \subseteq A \wedge \exists x \in A\; .\; x \notin B.$$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Third Definition.&lt;/strong&gt; A set $S$ is &lt;em&gt;third-definition infinite&lt;/em&gt; if $|S|\; \geq |\mathbb{N}|$ (as defined on the previous page).  Namely, there is a &lt;em&gt;surjective function&lt;/em&gt; from $S$ to $\mathbb{N}$.&lt;/p&gt;

&lt;p&gt;Are the above three definitions of (standard) &lt;em&gt;infinite&lt;/em&gt; and &lt;em&gt;Dedekind-infinite&lt;/em&gt; and &lt;em&gt;third-definition infinite&lt;/em&gt;
equivalent definitions?&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A set $S$ is &lt;em&gt;countable&lt;/em&gt; if and only if there exists a
  surjective function from $\mathbb{N}$ to $S$.  (That is, $\le 1$ arrow
  out from $\mathbb{N}$, $\ge 1$ arrow in to $S$.) Using our notation defined above, this means $|S|\; \leq |\mathbb{N}|$.&lt;/p&gt;

&lt;p&gt;Prove that these sets are countable: $\mathbb{Z}$, $\mathbb{N} \times
\mathbb{N}$, $\mathbb{Q}$ (rationals), $\emptyset$, $\mathbb{N} \cup (\mathbb{N} \times \mathbb{N}) \cup (\mathbb{N} \times \mathbb{N} \times \mathbb{N})$, all finite sequences of elements of $\mathbb{N}$.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A set $S$ is &lt;em&gt;countably infinite&lt;/em&gt; if and only if it is &lt;em&gt;countable&lt;/em&gt; and it is &lt;em&gt;infinite&lt;/em&gt; (according to standard definition).&lt;/p&gt;

&lt;p&gt;Must a &lt;em&gt;countable&lt;/em&gt; set that is &lt;em&gt;Dedekind-infinite&lt;/em&gt; be &lt;em&gt;countably infinite&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;Using the definition of countable, and third definition of infinite, show that $S$ is countably infinite if and only if there is a bijection between $S$ and $\mathbb{N}$. (We might as well use this definition in the future.)&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Problem Set 7</title>
      <link>https://uvacs2102.github.io/ps7posted/</link>
      <pubDate>Fri, 20 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/ps7posted/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://uvacs2102.github.io/ps/ps7&#34;&gt;&lt;strong&gt;Problem Set 7&lt;/strong&gt;&lt;/a&gt; [&lt;a href=&#34;https://uvacs2102.github.io/docs/ps7.pdf&#34;&gt;PDF&lt;/a&gt;] is now posted and
is due &lt;strong&gt;Friday, 27 Oct at 6:29:00pm&lt;/strong&gt;. Please read the
collaboration policy carefully.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Problem Set 7</title>
      <link>https://uvacs2102.github.io/ps/ps7/</link>
      <pubDate>Fri, 20 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/ps/ps7/</guid>
      <description>

&lt;div class=&#34;latex&#34;&gt;
   \dbox{{\bf Deliverable:} Submit your responses as a
single, readable PDF file on the collab site before {\bf 6:29pm} on {\bf
   Friday, 27 Oct}.  
}
&lt;/div&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;
   &lt;div class=&#34;highlightr&#34;&gt;
   &lt;strong&gt;Deliverable:&lt;/strong&gt; Submit your responses as a
single, readable PDF file on the collab site before &lt;strong&gt;6:29pm&lt;/strong&gt; on
   &lt;strong&gt;Friday, 27 October&lt;/strong&gt;.
   &lt;/div&gt;
   &lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;h3 id=&#34;collaboration-policy-identical-to-ps5&#34;&gt;Collaboration Policy (identical to PS5)&lt;/h3&gt;

&lt;p&gt;For this assignment, you may work in groups of one to three students
to write-up a solution together.  If you work with teammates, exactly
one of your should submit one assignment that represents your
collective best work with all of your names and UVA ids clearly marked
on it on it.  &lt;em&gt;Everyone on a team should understand everything you
turn in for the assignment well enough to be able to produce it
completely on your own.&lt;/em&gt; All teammates must review the submissions
before it is submitted to make sure you understand everything on it
and that your name and UVA id are clearly marked on it.&lt;/p&gt;

&lt;h2 id=&#34;preparation&#34;&gt;Preparation&lt;/h2&gt;

&lt;p&gt;This problem set focuses on recursive data types and structural
induction &amp;mdash; read Chapter 7 of the MCS book, and &lt;a href=&#34;https://uvacs2102.github.io/class15&#34;&gt;Class 15&lt;/a&gt;
and &lt;a href=&#34;https://uvacs2102.github.io/class16&#34;&gt;Class 16&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;directions&#34;&gt;Directions&lt;/h2&gt;

&lt;p&gt;Problems 1&amp;ndash;8 are expected for everyone; solve as many as you can.  The
Programming with Procedures problems are optional (see the note before
them).&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightm&#34;&gt;
    &lt;a href=&#34;https://uvacs2102.github.io/docs/ps7.pdf&#34;&gt;Download PDF for Problems&lt;/a&gt;.
   &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightr&#34;&gt;
Your response should be submitted as a single PDF file using collab.  Please read and follow the &lt;a href=&#34;https://uvacs2102.github.io/pdfs/&#34;&gt;Generating PDFs&lt;/a&gt; advice on the course site.
   &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;latex&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;tsilly-lists&#34;&gt;Tsilly Lists&lt;/h2&gt;

&lt;p&gt;Consider an alternate way of defining a list from the one we used in
Class 15 and 16, where instead of &lt;em&gt;prepend&lt;/em&gt;, lists are constructed using
&lt;em&gt;postpend&lt;/em&gt; (to avoid confusion, we call our postpended list a &lt;em&gt;tsil&lt;/em&gt;,
and reserve &lt;em&gt;list&lt;/em&gt; for the original prepended list):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A &lt;em&gt;tsil&lt;/em&gt; is either the empty tsil ($\lambda$), or the result of
  $\text{postpend}(t, e)$ for some tsil $t$ and object $e$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Define the meaning of the following operations (similarly to the
beginning of &lt;a href=&#34;https://uvacs2102.github.io/class16&#34;&gt;Class 16&lt;/a&gt;) for the tsil: $\text{last}: Tsil
\rightarrow Object$, $\text{frest}: Tsil \rightarrow Tsil$, and
$\text{empty}: Tsil \rightarrow Boolean$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Provide a constructive definition of &lt;em&gt;length&lt;/em&gt; for the tsil data type.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Prove that there is an equivalent tsil for every list.  (Your answer
should include a clear definition of what &lt;em&gt;equivalent&lt;/em&gt; means.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;structural-induction-on-trees&#34;&gt;Structural Induction on Trees&lt;/h2&gt;

&lt;p&gt;In &lt;a href=&#34;https://uvacs2102.github.io/class16&#34;&gt;Class 16&lt;/a&gt;, we defined a recursive data type, lists, that
only relied on &lt;em&gt;one&lt;/em&gt; (smaller) list in its recursive definition.  Here
we give a recursive definition for the data type of \emph{binary}
trees. In a binary tree, each node can have 0,1,or 2 children, and
each node has a label of its own that (in this case) is always a
natural number.&lt;/p&gt;

&lt;p&gt;The main two operators corresponding to the base and the construct cases are are:&lt;/p&gt;

&lt;p&gt;\begin{equation&lt;em&gt;}
\begin{split}
\qquad &amp;amp; \text{\bf null}: \text{\em Tree} &lt;br /&gt;
       &amp;amp; \text{node}: \text{\em Tree} \times \mathbb{N} \times \text{\em Tree} \rightarrow \text{\em Tree}
\end{split}
\end{equation&lt;/em&gt;}&lt;/p&gt;

&lt;p&gt;We also define the following operations on binary trees.&lt;/p&gt;

&lt;p&gt;The meaning of the operations is defined for all trees $t_1, t_2$, and all $n \in \mathbb{N}$, by:
\begin{equation&lt;em&gt;}
\begin{split}
\text{label}: \text{\em Tree} \rightarrow \mathbb{N} \colon \qquad &amp;amp; \text{label}(\text{node}(t_1, n, t_2)) \rightarrow n &lt;br /&gt;
\text{left}: \text{\em Tree} \rightarrow \text{\em Tree} \colon  \qquad &amp;amp; \text{left}(\text{node}(t_1, n, t_2)) \rightarrow t_1 &lt;br /&gt;
\text{right}: \text{\em Tree} \rightarrow \text{\em Tree} \colon \qquad &amp;amp; \text{right}(\text{node}(t_1, n, t_2)) \rightarrow t_2 &lt;br /&gt;
\text{empty}: \text{\em Tree} \rightarrow { \T, \F } \colon  \qquad &amp;amp; \text{empty}(\text{\bf null}) \rightarrow \T &lt;br /&gt;
\qquad &amp;amp; \text{empty}(\text{node}(t_1, n, t_2) \rightarrow \F &lt;br /&gt;
\end{split}
\end{equation&lt;/em&gt;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;em&gt;height&lt;/em&gt; of a tree is the &lt;em&gt;maximum&lt;/em&gt; distance (number of edges) from
its root (the one node that has no parent node) to a leaf. For example the hight of the tree at the bottom of this page is 2. Provide a
&lt;em&gt;constructive&lt;/em&gt; definition of &lt;em&gt;height&lt;/em&gt; for our binary tree type.  (Hint:
the height of $\text{node}(\text{\bf null}, n, \text{\bf null})$ is
$0$.  The height of $\text{\bf null}$ should also be $0$.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Prove that the maximum number of nodes in a binary tree of height $h$
is $2^{h + 1} - 1$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The in-order traversal of a binary tree is a list of the node labels in
the order they appear from left-to-right across the tree.  For example,
the in-order traversal of the tree shown below would be the list $(4, 8,
9, 13, 22, 27)$.&lt;/p&gt;

&lt;p&gt;\begin{center}
\includegraphics[scale=0.7]{./content/docs/binarytree.pdf}
\end{center}&lt;/p&gt;

&lt;p&gt;We can define $\text{traverse}$ to produce a (prepend) list as follows (note the $+$ operation here is list concatenation, as defined in &lt;a href=&#34;https://uvacs2102.github.io/class16&#34;&gt;Class 16&lt;/a&gt;) :
\begin{equation&lt;em&gt;}
\begin{split}
&amp;amp; \text{traverse}(\text{\bf null}) = \text{\bf null} &lt;br /&gt;
&amp;amp; \text{traverse}(\text{node}(t_1, n, t_2)) = \text{traverse}(t_1) + \text{prepend}(n, \text{traverse}(t_2)) &lt;br /&gt;
\end{split}
\end{equation&lt;/em&gt;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Prove that for all trees $t$ with $n$ nodes, the result of
$\text{traverse(t)}$ is a list of length $n$.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;ordered-binary-trees&#34;&gt;Ordered Binary Trees&lt;/h2&gt;

&lt;p&gt;Here we would like to  define an $\text{\em OrderedBinaryTree}$ as a data type where for each node  with label $n$, all of the children in the left sub-tree have labels &lt;em&gt;smaller&lt;/em&gt; than $n$, and all the children in the right sub-tree have labels &lt;em&gt;larger&lt;/em&gt; than $n$.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Base case:&lt;/strong&gt; $\text{\bf null} \in \text{\em OrderedBinaryTree}$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Constructor case:&lt;/strong&gt; if $t_1, t_2 \in \text{\em OrderedBinaryTree}$
and $n \in \mathbb{N}$, and $(\text{empty}(t_1) \vee \text{maximum}(t_1) &amp;lt; n)$ and
$(\text{empty}(t_1) \vee \text{minimum}(t_2) &amp;gt; n)$, then $\text{node}(t_1, n, t_2) \in \text{\em OrderedBinaryTree}$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You may assume all the other tree operations (including
$\text{traverse}$ from question 5) are defined for \text{\em
OrderedBinaryTree} s also.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Define the $\text{minimum}: \text{\em OrderedBinaryTree} \rightarrow
\mathbb{N}$ and $\text{maximum}: \text{\em OrderedBinaryTree}
\rightarrow \mathbb{N}$ operations used in the definition of $\text{\em
OrderedBinaryTree}$ above.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;($\star$) Prove that $\forall t \in \text{\em OrderedBinaryTree}
\ldotp \text{traverse}(t)$ is an ordered list.  (A list, $p = (p_1, p_2,
\cdots, p_n)$ is an ordered list if $\forall i \in { 1, \cdots, n-1 }
\ldotp p&lt;em&gt;i &amp;lt; p&lt;/em&gt;{i + 1}$.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;programming-with-procedures&#34;&gt;Programming with Procedures&lt;/h2&gt;

&lt;p&gt;\dbox{These problems are {\em optional}, and provided to give students
who are interested some experience with functional programming which
will make you a more powerful, snazzy, and prolific programmer.  You
do not need to do them to earn &amp;ldquo;gold star&amp;rdquo; level credit on this
assignment, and nothing on the exams will depend on them.  You will
receive &amp;ldquo;bonus&amp;rdquo; credit on this assignment for turning in good answers
to these questions.}&lt;/p&gt;

&lt;p&gt;These questions assume you have some experience programming in Python,
but are sadly lacking in previous experience using procedures as
parameters and results and realize that you cannot be a true kunoichi
programmer without becoming adept with programming with procedures.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt; &lt;a href=&#34;https://uvacs2102.github.io/docs/pairs.py&#34;&gt;pairs.py&lt;/a&gt; (if the link in the PDF file doesn&amp;rsquo;t work, use &lt;em&gt;&lt;a href=&#34;https://uvacs2102.github.io/docs/pairs.py&#34;&gt;https://uvacs2102.github.io/docs/pairs.py&lt;/a&gt;&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://uvacs2102.github.io/docs/pairs.py&#34;&gt;pairs.py&lt;/a&gt;, we defined &lt;code&gt;make_pair&lt;/code&gt; and various
procedures for building and using lists.  You should download this code,
run it in your favorite Python3 environment, and make sure you
understand it.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Define a function &lt;code&gt;list_tostring(lst)&lt;/code&gt; that takes a list (constructed
using the &lt;code&gt;list_append&lt;/code&gt; function from &lt;code&gt;pairs.py&lt;/code&gt;) as its input and
returns a string representation of that list.  For example,
&lt;code&gt;list_tostring(list_prepend(1, list_prepend(2, list_prepend(3, None))))&lt;/code&gt;
should print out &lt;code&gt;[1, 2, 3]&lt;/code&gt;.  (You can use &lt;code&gt;str(x)&lt;/code&gt; to turn any Python
object &lt;code&gt;x&lt;/code&gt; into a string.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Define a function &lt;code&gt;list_map(fn, lst)&lt;/code&gt; that takes as inputs a
function and a list, and returns a list that is the result of applying
the input function to each element of &lt;code&gt;lst&lt;/code&gt;.  For example,
&lt;code&gt;list_map(lambda x: x + 1, list123)&lt;/code&gt;
should return the list &lt;code&gt;[2, 3, 4]&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Define a function &lt;code&gt;list_accumulate(fn, lst, base)&lt;/code&gt; that takes as
inputs a function, a list, and a base value, and returns the result of
applying the function through the list.  For example,
&lt;code&gt;list_accumulate(lambda a, b: a + b, lst, 0)&lt;/code&gt;
should return the sum of all the elements in the list, and
&lt;code&gt;list_accumulate(lambda a, b: a * b, lst, 1)&lt;/code&gt;
should return their product, and &lt;code&gt;list_accumulate(lambda a, b: b + 1, lst, 0)&lt;/code&gt;
should return the length of the list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Define &lt;code&gt;list_map&lt;/code&gt; (as in problem 10) using &lt;code&gt;list_accumulate&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Class 16: Structural Induction</title>
      <link>https://uvacs2102.github.io/class16/</link>
      <pubDate>Thu, 19 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/class16/</guid>
      <description>

&lt;h3 id=&#34;schedule&#34;&gt;Schedule&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://uvacs2102.github.io/ps/ps7&#34;&gt;&lt;strong&gt;Problem Set 6&lt;/strong&gt;&lt;/a&gt; is due &lt;strong&gt;tomorrow at 6:29pm&lt;/strong&gt;. Make sure to read the corrected version of Problem 7.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;
   &lt;center&gt;
&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;df7755f817fe4902abc3b73573f79752&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
   &lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightm&#34;&gt;
   &lt;a href=&#34;https://uvacs2102.github.io/docs/class16.pdf&#34;&gt;See PDF Version for &lt;b&gt;Notes&lt;/b&gt;&lt;/a&gt;.
   &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;latex&#34;&gt;&lt;/p&gt;

&lt;h1 id=&#34;lists&#34;&gt;Lists&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A &lt;em&gt;list&lt;/em&gt; is an ordered sequence of objects.  A list is
  either the empty list ($\lambda$), or the result of $\text{prepend}(e,
  l)$ for some object $e$ and list $l$.&lt;/p&gt;

&lt;p&gt;\begin{equation&lt;em&gt;}
\begin{split}
\text{\em first}(\text{prepend}(e, l)) &amp;amp;= e &lt;br /&gt;
\text{\em rest}(\text{prepend}(e, l)) &amp;amp;= l &lt;br /&gt;
\text{\em empty}(\text{prepend}(e, l)) &amp;amp;= \text{\bf False} &lt;br /&gt;
\text{\em empty}(\text{\bf null}) &amp;amp;= \text{\bf True} &lt;br /&gt;
\end{split}
\end{equation&lt;/em&gt;}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; The &lt;em&gt;length&lt;/em&gt; of a list, $p$, is:
\begin{equation&lt;em&gt;}
\begin{split}
\begin{cases}
0 &amp;amp; \text{if}\ p\ \text{is \bf null} &lt;br /&gt;
\text{\em length}(q) + 1 &amp;amp; \text{otherwise}\ p = \text{\em prepend}(e, q)\ \text{for some object}\ e\ \text{and some list}\ q &lt;br /&gt;
\end{cases}
\end{split}
\end{equation&lt;/em&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;def list_length(l):
    if list_empty(l):
        return 0
    else:
        return 1 + list_length(list_rest(l))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prove: for all lists, $p$, &lt;code&gt;list_length(p)&lt;/code&gt; returns the length of the list $p$.&lt;/p&gt;

&lt;!--page--&gt;

&lt;h2 id=&#34;concatenation&#34;&gt;Concatenation&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; The &lt;em&gt;concatenation&lt;/em&gt; of two lists, $p = (p_1, p_2, \cdots, p_n)$ and $q = (q_1, q_2, \cdots, q_m)$ is
$$(p_1, p_2, \cdots, p_n, q_1, q_2, \cdots, q_m).$$&lt;/p&gt;

&lt;p&gt;Provide a &lt;em&gt;constructuve&lt;/em&gt; definition of &lt;em&gt;concatenation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Note that $\text{prepend}(p,q)$ is not a good idea for two reasons. If we use this definition, then the first element of the constructed list will be the object (list) $p$ (as a whole) rather than the first element $p_1$ of the list $p$. Also, if we want to &lt;em&gt;only&lt;/em&gt; define lists of &lt;em&gt;specific&lt;/em&gt; objects, for example integers, we can still use the same recursive/constructive definition of lists by substituting &amp;ldquo;object&amp;rdquo; with &amp;ldquo;integer&amp;rdquo;, but in that case $\text{prepend}(p,q)$ will not even well defined, as it can only accept integers as first input.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h2 id=&#34;structural-induction&#34;&gt;Structural Induction&lt;/h2&gt;

&lt;p&gt;To prove proposition $P(x)$ for element $x \in D$ where $D$ is a
recursively-constructed data type, we do two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Show $P(x)$ is true for all $x \in D$ that are defined using base cases.&lt;/li&gt;
&lt;li&gt;Show that if $P(y)$ is true for element $y$ and $x$ is constructed from $y$
using any &amp;ldquo;construct case&amp;rdquo; rules, then $P(x)$ is true as well.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;comparing-various-forms-of-induction&#34;&gt;Comparing Various forms of Induction&lt;/h2&gt;

&lt;p&gt;\begin{center}
\begin{tabular}{lccc}
&amp;amp; {\bf Regular Induction} &amp;amp; {\bf Invariant Principle} &amp;amp; {\bf Structural Induction} \ \hline
Works on: &amp;amp; natural numbers &amp;amp; state machines &amp;amp; data types &lt;br /&gt;
To prove $P(\cdot)$ &amp;amp; {\em for all natural numbers} &amp;amp; {\em for all reachable states} &amp;amp; {\em for all data type objects} &lt;br /&gt;
Prove {\bf base case(s)} &amp;amp; $P(0)$ &amp;amp; $P(q_0)$ &amp;amp; $P(\text{base object(s)})$ &lt;br /&gt;
and {\bf inductive step} &amp;amp; $\forall m \in \mathbb{N} \ldotp$ &amp;amp; $\forall (q, r) \in G \ldotp $ &amp;amp; $\forall s \in \text{\em Type} \ldotp$ &lt;br /&gt;
  &amp;amp; $P(m) \implies P(m+1)$ &amp;amp; $P(q) \implies P&amp;reg;$ &amp;amp; $P(s) \implies P(t)$ &lt;br /&gt;
 &amp;amp; &amp;amp; &amp;amp; $\quad \forall t\ \text{constructable from}\ s$ \
\end{tabular}
\end{center}&lt;/p&gt;

&lt;p&gt;#
##&lt;/p&gt;

&lt;p&gt;Prove. For any two lists, $p$ and $q$, $\text{length}(p + q) = \text{length}(p) + \text{length}(q)$.&lt;/p&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Class 15: Recursive Data Types</title>
      <link>https://uvacs2102.github.io/class15/</link>
      <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://uvacs2102.github.io/class15/</guid>
      <description>

&lt;h3 id=&#34;schedule&#34;&gt;Schedule&lt;/h3&gt;

&lt;p&gt;You should read MCS Chapter 7 this week.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://uvacs2102.github.io/ps/ps6&#34;&gt;&lt;strong&gt;Problem Set 6&lt;/strong&gt;&lt;/a&gt; is due &lt;strong&gt;20 October (Friday) at 6:29pm&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notpdf&#34;&gt;
   &lt;center&gt;
&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;9d25492c6e134346a212652c6d0052ab&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
   &lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;Python code from class and list definitions: &lt;a href=&#34;https://uvacs2102.github.io/docs/pairs.py&#34;&gt;pairs.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlightm&#34;&gt;
   &lt;a href=&#34;https://uvacs2102.github.io/docs/class15.pdf&#34;&gt;See PDF Version for &lt;b&gt;Notes&lt;/b&gt;&lt;/a&gt;.
   &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;!--endpdf--&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;latex&#34;&gt;&lt;/p&gt;

&lt;h1 id=&#34;proving-correctness&#34;&gt;Proving Correctness&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def slow_power(a, b):
   y = 1
   z = b
   while z &amp;gt; 0:
      y = y * a
      z = z - 1
   return y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We model the Python program with a state machine:&lt;/p&gt;

&lt;p&gt;$S ::= \mathbb{N} \times \mathbb{N}$&lt;br /&gt;
$G ::= { (y, z) \rightarrow (y \cdot a, z - 1) \, | \, \forall y, z \in \mathbb{N}^{+}}$&lt;br /&gt;
$q_0 ::= (1, b)$&lt;/p&gt;

&lt;p&gt;It is important to remember this is a &lt;em&gt;model&lt;/em&gt;. It does not capture
many important aspects of execution of a real Python program. In
particular, it only models inputs in $\mathbb{N}$, when the actual
inputs could be other types in PYthon.  It also assume all math
opderations work mathematically, not Pythonically.&lt;/p&gt;

&lt;p&gt;To prove partial correctness, we show $P(q = (y, z)) := y = a^{b-z}$
is a &lt;em&gt;preserved invariant&lt;/em&gt;. Then, we show that it holds in state
$q_0$.  Finally, we show that in all final states, $y = a^b$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Invariant is Preserved:&lt;/strong&gt; We need to show that $\forall q \in S . \forall t \in S . (q, t) \in G \implies P(q) \implies P(t)$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$q = (y, z)$. $P(q = (y, z))$: $y = a^{b-z}$.&lt;/li&gt;
&lt;li&gt;If there is an edge from $q$ to $t$, that means $t = (y \cdot a, z-1)$ and $z \ge 1$ since this is the only edge from $q$ in $G$.&lt;/li&gt;
&lt;li&gt;We show $P(t = (y \cdot a, z-1))$ holds by multiplying both sides of $P(q)$ by $a$: $$ya = (a^{b -z}) \cdot a = a^{b - z + 1} = a ^{b - (z - 1)}.$$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Invariant holds in $q_0$:&lt;/strong&gt; $q_0 = (1, b)$. So, we need to show $P(q_0 = (1, b))$: $1 = a^{b - b}$. This holds since $a^{0} = 1$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Final states:&lt;/strong&gt; All states where $z \ge 1$ have an outgoing edge, but no states where $z = 0$ do. So, the final states are all of the form $(\alpha, 0)$. If a final state is reachable from $q_0$, the invariant must hold since we proved it is preserve. Hence, in the final state $(\alpha, 0)$ we know $\alpha = a^{b}$.&lt;/p&gt;

&lt;p&gt;This proves &lt;em&gt;partial correctness&lt;/em&gt;: if the program terminates, it
terminates in a state where the property ($y = a^b$ is satisfied).  To
prove &lt;em&gt;total correctness&lt;/em&gt; we also need to know the execution
&lt;em&gt;eventually&lt;/em&gt; reaches a final state.&lt;/p&gt;

&lt;p&gt;We prove this by showing that from any initial state $q_0 = (1, b)$,
the machine will reach a final state $q_f = (y, 0)$ in $b$ steps.  The
proof in class used the Well Ordering Principle. You could also prove
this using regular Induction.&lt;/p&gt;

&lt;h1 id=&#34;pairs&#34;&gt;Pairs&lt;/h1&gt;

&lt;p&gt;What is the difference between scalar data and compound data structures?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; A $\text{\em Pair}$ is a datatype that supports these three operations:&lt;br /&gt;
\begin{quote}
     $\text{\em make_pair}: \text{\em Object} \times \text{\em Object} \rightarrow \text{\em Pair}$&lt;br /&gt;
     $\text{\em pair_first}: \text{\em Pair} \rightarrow \text{\em Object}$\&lt;br /&gt;
     $\text{\em pair_last}: \text{\em Pair} \rightarrow \text{\em Object}$\&lt;br /&gt;
\end{quote}
where, for any objects $a$ and $b$, $\text{\em pair_first}(\text{\em make_pair}(a, b)) = a$ and $\text{\em pair_last}(\text{\em make_pair}(a, b)) = b$.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;def make_pair(a, b):
    def selector(which):
        if which:
            return a
        else:
            return b
    return selector

def pair_first(p):
    return p(True)

def pair_last(p):
    return p(False)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;lists&#34;&gt;Lists&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition (1).&lt;/strong&gt; A &lt;em&gt;List&lt;/em&gt; is either (1) a &lt;em&gt;Pair&lt;/em&gt; where the second part of
  the pair is a &lt;em&gt;List&lt;/em&gt;, or (2) the empty list.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition (2).&lt;/strong&gt; A &lt;em&gt;List&lt;/em&gt; is a ordered sequence of objects.&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>